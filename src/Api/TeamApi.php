<?php

/**
 *
 * Kimai API Client 2020 — NOTICE OF LICENSE
 * This source file is released under MIT license by copyright holders.
 * @copyright 2017-2020 (c) Niko Granö (https://granö.fi)
 * @copyright 2014-2020 (c) Fiteco Group Oy (https://group.fiteco.fi)
 *
 */

/**
 * Kimai 2 - API Docs.
 *
 * JSON API for the Kimai 2 time-tracking software. Read more about its usage in the [API documentation](https://www.kimai.org/documentation/rest-api.html) and then download a [Swagger file](doc.json) for import e.g. in Postman. Be aware: it is not yet considered stable and BC breaks might happen, especially when using code generation. The order of JSON attributes is not guaranteed.
 *
 * The version of the OpenAPI document: 0.6
 *
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Fiteco\KimaiClient\Api;

use Fiteco\KimaiClient\ApiException;
use Fiteco\KimaiClient\Configuration;
use Fiteco\KimaiClient\HeaderSelector;
use Fiteco\KimaiClient\ObjectSerializer;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;

/**
 * TeamApi Class Doc Comment.
 *
 * @category Class
 *
 * @author   OpenAPI Generator team
 *
 * @see     https://openapi-generator.tech
 */
class TeamApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index.
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex)
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index.
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation apiTeamsGet.
     *
     * Fetch all existing teams
     *
     * @throws \Fiteco\KimaiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Fiteco\KimaiClient\Model\TeamCollection[]
     */
    public function apiTeamsGet()
    {
        [$response] = $this->apiTeamsGetWithHttpInfo();

        return $response;
    }

    /**
     * Operation apiTeamsGetWithHttpInfo.
     *
     * Fetch all existing teams
     *
     * @throws \Fiteco\KimaiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Fiteco\KimaiClient\Model\TeamCollection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTeamsGetWithHttpInfo()
    {
        $request = $this->apiTeamsGetRequest();

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $request->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            switch ($statusCode) {
                case 200:
                    if ('\Fiteco\KimaiClient\Model\TeamCollection[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Fiteco\KimaiClient\Model\TeamCollection[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Fiteco\KimaiClient\Model\TeamCollection[]';
            $responseBody = $response->getBody();
            if ('\SplFileObject' === $returnType) {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Fiteco\KimaiClient\Model\TeamCollection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation apiTeamsGetAsync.
     *
     * Fetch all existing teams
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsGetAsync()
    {
        return $this->apiTeamsGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTeamsGetAsyncWithHttpInfo.
     *
     * Fetch all existing teams
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsGetAsyncWithHttpInfo()
    {
        $returnType = '\Fiteco\KimaiClient\Model\TeamCollection[]';
        $request = $this->apiTeamsGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ('\SplFileObject' === $returnType) {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
                }
            );
    }

    /**
     * Create request for operation 'apiTeamsGet'.
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiTeamsGetRequest()
    {
        $resourcePath = '/api/teams';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (\count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = \is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name'     => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if (null !== $apiKey) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if (null !== $apiKey) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTeamsIdActivitiesActivityIdDelete.
     *
     * Revokes access for an activity from a team
     *
     * @param int $id         The team whose permission will be revoked (required)
     * @param int $activityId The activity to remove (Activity ID) (required)
     *
     * @throws \Fiteco\KimaiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Fiteco\KimaiClient\Model\TeamEntity
     */
    public function apiTeamsIdActivitiesActivityIdDelete($id, $activityId)
    {
        [$response] = $this->apiTeamsIdActivitiesActivityIdDeleteWithHttpInfo($id, $activityId);

        return $response;
    }

    /**
     * Operation apiTeamsIdActivitiesActivityIdDeleteWithHttpInfo.
     *
     * Revokes access for an activity from a team
     *
     * @param int $id         The team whose permission will be revoked (required)
     * @param int $activityId The activity to remove (Activity ID) (required)
     *
     * @throws \Fiteco\KimaiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Fiteco\KimaiClient\Model\TeamEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTeamsIdActivitiesActivityIdDeleteWithHttpInfo($id, $activityId)
    {
        $request = $this->apiTeamsIdActivitiesActivityIdDeleteRequest($id, $activityId);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $request->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            switch ($statusCode) {
                case 200:
                    if ('\Fiteco\KimaiClient\Model\TeamEntity' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Fiteco\KimaiClient\Model\TeamEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Fiteco\KimaiClient\Model\TeamEntity';
            $responseBody = $response->getBody();
            if ('\SplFileObject' === $returnType) {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Fiteco\KimaiClient\Model\TeamEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation apiTeamsIdActivitiesActivityIdDeleteAsync.
     *
     * Revokes access for an activity from a team
     *
     * @param int $id         The team whose permission will be revoked (required)
     * @param int $activityId The activity to remove (Activity ID) (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsIdActivitiesActivityIdDeleteAsync($id, $activityId)
    {
        return $this->apiTeamsIdActivitiesActivityIdDeleteAsyncWithHttpInfo($id, $activityId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTeamsIdActivitiesActivityIdDeleteAsyncWithHttpInfo.
     *
     * Revokes access for an activity from a team
     *
     * @param int $id         The team whose permission will be revoked (required)
     * @param int $activityId The activity to remove (Activity ID) (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsIdActivitiesActivityIdDeleteAsyncWithHttpInfo($id, $activityId)
    {
        $returnType = '\Fiteco\KimaiClient\Model\TeamEntity';
        $request = $this->apiTeamsIdActivitiesActivityIdDeleteRequest($id, $activityId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ('\SplFileObject' === $returnType) {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
                }
            );
    }

    /**
     * Create request for operation 'apiTeamsIdActivitiesActivityIdDelete'.
     *
     * @param int $id         The team whose permission will be revoked (required)
     * @param int $activityId The activity to remove (Activity ID) (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiTeamsIdActivitiesActivityIdDeleteRequest($id, $activityId)
    {
        // verify the required parameter 'id' is set
        if (null === $id || (\is_array($id) && 0 === \count($id))) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling apiTeamsIdActivitiesActivityIdDelete');
        }
        // verify the required parameter 'activityId' is set
        if (null === $activityId || (\is_array($activityId) && 0 === \count($activityId))) {
            throw new \InvalidArgumentException('Missing the required parameter $activityId when calling apiTeamsIdActivitiesActivityIdDelete');
        }

        $resourcePath = '/api/teams/{id}/activities/{activityId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if (null !== $id) {
            $resourcePath = str_replace(
                '{'.'id'.'}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if (null !== $activityId) {
            $resourcePath = str_replace(
                '{'.'activityId'.'}',
                ObjectSerializer::toPathValue($activityId),
                $resourcePath
            );
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (\count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = \is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name'     => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if (null !== $apiKey) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if (null !== $apiKey) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'DELETE',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTeamsIdActivitiesActivityIdPost.
     *
     * Grant the team access to an activity
     *
     * @param int $id         The team that is granted access (required)
     * @param int $activityId The activity to grant acecess to (Activity ID) (required)
     *
     * @throws \Fiteco\KimaiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Fiteco\KimaiClient\Model\TeamEntity
     */
    public function apiTeamsIdActivitiesActivityIdPost($id, $activityId)
    {
        [$response] = $this->apiTeamsIdActivitiesActivityIdPostWithHttpInfo($id, $activityId);

        return $response;
    }

    /**
     * Operation apiTeamsIdActivitiesActivityIdPostWithHttpInfo.
     *
     * Grant the team access to an activity
     *
     * @param int $id         The team that is granted access (required)
     * @param int $activityId The activity to grant acecess to (Activity ID) (required)
     *
     * @throws \Fiteco\KimaiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Fiteco\KimaiClient\Model\TeamEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTeamsIdActivitiesActivityIdPostWithHttpInfo($id, $activityId)
    {
        $request = $this->apiTeamsIdActivitiesActivityIdPostRequest($id, $activityId);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $request->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            switch ($statusCode) {
                case 200:
                    if ('\Fiteco\KimaiClient\Model\TeamEntity' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Fiteco\KimaiClient\Model\TeamEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Fiteco\KimaiClient\Model\TeamEntity';
            $responseBody = $response->getBody();
            if ('\SplFileObject' === $returnType) {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Fiteco\KimaiClient\Model\TeamEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation apiTeamsIdActivitiesActivityIdPostAsync.
     *
     * Grant the team access to an activity
     *
     * @param int $id         The team that is granted access (required)
     * @param int $activityId The activity to grant acecess to (Activity ID) (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsIdActivitiesActivityIdPostAsync($id, $activityId)
    {
        return $this->apiTeamsIdActivitiesActivityIdPostAsyncWithHttpInfo($id, $activityId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTeamsIdActivitiesActivityIdPostAsyncWithHttpInfo.
     *
     * Grant the team access to an activity
     *
     * @param int $id         The team that is granted access (required)
     * @param int $activityId The activity to grant acecess to (Activity ID) (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsIdActivitiesActivityIdPostAsyncWithHttpInfo($id, $activityId)
    {
        $returnType = '\Fiteco\KimaiClient\Model\TeamEntity';
        $request = $this->apiTeamsIdActivitiesActivityIdPostRequest($id, $activityId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ('\SplFileObject' === $returnType) {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
                }
            );
    }

    /**
     * Create request for operation 'apiTeamsIdActivitiesActivityIdPost'.
     *
     * @param int $id         The team that is granted access (required)
     * @param int $activityId The activity to grant acecess to (Activity ID) (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiTeamsIdActivitiesActivityIdPostRequest($id, $activityId)
    {
        // verify the required parameter 'id' is set
        if (null === $id || (\is_array($id) && 0 === \count($id))) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling apiTeamsIdActivitiesActivityIdPost');
        }
        // verify the required parameter 'activityId' is set
        if (null === $activityId || (\is_array($activityId) && 0 === \count($activityId))) {
            throw new \InvalidArgumentException('Missing the required parameter $activityId when calling apiTeamsIdActivitiesActivityIdPost');
        }

        $resourcePath = '/api/teams/{id}/activities/{activityId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if (null !== $id) {
            $resourcePath = str_replace(
                '{'.'id'.'}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if (null !== $activityId) {
            $resourcePath = str_replace(
                '{'.'activityId'.'}',
                ObjectSerializer::toPathValue($activityId),
                $resourcePath
            );
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (\count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = \is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name'     => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if (null !== $apiKey) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if (null !== $apiKey) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTeamsIdCustomersCustomerIdDelete.
     *
     * Revokes access for a customer from a team
     *
     * @param int $id         The team whose permission will be revoked (required)
     * @param int $customerId The customer to remove (Customer ID) (required)
     *
     * @throws \Fiteco\KimaiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Fiteco\KimaiClient\Model\TeamEntity
     */
    public function apiTeamsIdCustomersCustomerIdDelete($id, $customerId)
    {
        [$response] = $this->apiTeamsIdCustomersCustomerIdDeleteWithHttpInfo($id, $customerId);

        return $response;
    }

    /**
     * Operation apiTeamsIdCustomersCustomerIdDeleteWithHttpInfo.
     *
     * Revokes access for a customer from a team
     *
     * @param int $id         The team whose permission will be revoked (required)
     * @param int $customerId The customer to remove (Customer ID) (required)
     *
     * @throws \Fiteco\KimaiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Fiteco\KimaiClient\Model\TeamEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTeamsIdCustomersCustomerIdDeleteWithHttpInfo($id, $customerId)
    {
        $request = $this->apiTeamsIdCustomersCustomerIdDeleteRequest($id, $customerId);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $request->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            switch ($statusCode) {
                case 200:
                    if ('\Fiteco\KimaiClient\Model\TeamEntity' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Fiteco\KimaiClient\Model\TeamEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Fiteco\KimaiClient\Model\TeamEntity';
            $responseBody = $response->getBody();
            if ('\SplFileObject' === $returnType) {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Fiteco\KimaiClient\Model\TeamEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation apiTeamsIdCustomersCustomerIdDeleteAsync.
     *
     * Revokes access for a customer from a team
     *
     * @param int $id         The team whose permission will be revoked (required)
     * @param int $customerId The customer to remove (Customer ID) (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsIdCustomersCustomerIdDeleteAsync($id, $customerId)
    {
        return $this->apiTeamsIdCustomersCustomerIdDeleteAsyncWithHttpInfo($id, $customerId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTeamsIdCustomersCustomerIdDeleteAsyncWithHttpInfo.
     *
     * Revokes access for a customer from a team
     *
     * @param int $id         The team whose permission will be revoked (required)
     * @param int $customerId The customer to remove (Customer ID) (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsIdCustomersCustomerIdDeleteAsyncWithHttpInfo($id, $customerId)
    {
        $returnType = '\Fiteco\KimaiClient\Model\TeamEntity';
        $request = $this->apiTeamsIdCustomersCustomerIdDeleteRequest($id, $customerId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ('\SplFileObject' === $returnType) {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
                }
            );
    }

    /**
     * Create request for operation 'apiTeamsIdCustomersCustomerIdDelete'.
     *
     * @param int $id         The team whose permission will be revoked (required)
     * @param int $customerId The customer to remove (Customer ID) (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiTeamsIdCustomersCustomerIdDeleteRequest($id, $customerId)
    {
        // verify the required parameter 'id' is set
        if (null === $id || (\is_array($id) && 0 === \count($id))) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling apiTeamsIdCustomersCustomerIdDelete');
        }
        // verify the required parameter 'customerId' is set
        if (null === $customerId || (\is_array($customerId) && 0 === \count($customerId))) {
            throw new \InvalidArgumentException('Missing the required parameter $customerId when calling apiTeamsIdCustomersCustomerIdDelete');
        }

        $resourcePath = '/api/teams/{id}/customers/{customerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if (null !== $id) {
            $resourcePath = str_replace(
                '{'.'id'.'}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if (null !== $customerId) {
            $resourcePath = str_replace(
                '{'.'customerId'.'}',
                ObjectSerializer::toPathValue($customerId),
                $resourcePath
            );
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (\count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = \is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name'     => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if (null !== $apiKey) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if (null !== $apiKey) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'DELETE',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTeamsIdCustomersCustomerIdPost.
     *
     * Grant the team access to a customer
     *
     * @param int $id         The team that is granted access (required)
     * @param int $customerId The customer to grant acecess to (Customer ID) (required)
     *
     * @throws \Fiteco\KimaiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Fiteco\KimaiClient\Model\TeamEntity
     */
    public function apiTeamsIdCustomersCustomerIdPost($id, $customerId)
    {
        [$response] = $this->apiTeamsIdCustomersCustomerIdPostWithHttpInfo($id, $customerId);

        return $response;
    }

    /**
     * Operation apiTeamsIdCustomersCustomerIdPostWithHttpInfo.
     *
     * Grant the team access to a customer
     *
     * @param int $id         The team that is granted access (required)
     * @param int $customerId The customer to grant acecess to (Customer ID) (required)
     *
     * @throws \Fiteco\KimaiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Fiteco\KimaiClient\Model\TeamEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTeamsIdCustomersCustomerIdPostWithHttpInfo($id, $customerId)
    {
        $request = $this->apiTeamsIdCustomersCustomerIdPostRequest($id, $customerId);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $request->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            switch ($statusCode) {
                case 200:
                    if ('\Fiteco\KimaiClient\Model\TeamEntity' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Fiteco\KimaiClient\Model\TeamEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Fiteco\KimaiClient\Model\TeamEntity';
            $responseBody = $response->getBody();
            if ('\SplFileObject' === $returnType) {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Fiteco\KimaiClient\Model\TeamEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation apiTeamsIdCustomersCustomerIdPostAsync.
     *
     * Grant the team access to a customer
     *
     * @param int $id         The team that is granted access (required)
     * @param int $customerId The customer to grant acecess to (Customer ID) (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsIdCustomersCustomerIdPostAsync($id, $customerId)
    {
        return $this->apiTeamsIdCustomersCustomerIdPostAsyncWithHttpInfo($id, $customerId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTeamsIdCustomersCustomerIdPostAsyncWithHttpInfo.
     *
     * Grant the team access to a customer
     *
     * @param int $id         The team that is granted access (required)
     * @param int $customerId The customer to grant acecess to (Customer ID) (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsIdCustomersCustomerIdPostAsyncWithHttpInfo($id, $customerId)
    {
        $returnType = '\Fiteco\KimaiClient\Model\TeamEntity';
        $request = $this->apiTeamsIdCustomersCustomerIdPostRequest($id, $customerId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ('\SplFileObject' === $returnType) {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
                }
            );
    }

    /**
     * Create request for operation 'apiTeamsIdCustomersCustomerIdPost'.
     *
     * @param int $id         The team that is granted access (required)
     * @param int $customerId The customer to grant acecess to (Customer ID) (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiTeamsIdCustomersCustomerIdPostRequest($id, $customerId)
    {
        // verify the required parameter 'id' is set
        if (null === $id || (\is_array($id) && 0 === \count($id))) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling apiTeamsIdCustomersCustomerIdPost');
        }
        // verify the required parameter 'customerId' is set
        if (null === $customerId || (\is_array($customerId) && 0 === \count($customerId))) {
            throw new \InvalidArgumentException('Missing the required parameter $customerId when calling apiTeamsIdCustomersCustomerIdPost');
        }

        $resourcePath = '/api/teams/{id}/customers/{customerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if (null !== $id) {
            $resourcePath = str_replace(
                '{'.'id'.'}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if (null !== $customerId) {
            $resourcePath = str_replace(
                '{'.'customerId'.'}',
                ObjectSerializer::toPathValue($customerId),
                $resourcePath
            );
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (\count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = \is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name'     => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if (null !== $apiKey) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if (null !== $apiKey) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTeamsIdDelete.
     *
     * Delete a team
     *
     * @param int $id Team ID to delete (required)
     *
     * @throws \Fiteco\KimaiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return void
     */
    public function apiTeamsIdDelete($id)
    {
        $this->apiTeamsIdDeleteWithHttpInfo($id);
    }

    /**
     * Operation apiTeamsIdDeleteWithHttpInfo.
     *
     * Delete a team
     *
     * @param int $id Team ID to delete (required)
     *
     * @throws \Fiteco\KimaiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTeamsIdDeleteWithHttpInfo($id)
    {
        $request = $this->apiTeamsIdDeleteRequest($id);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $request->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }

    /**
     * Operation apiTeamsIdDeleteAsync.
     *
     * Delete a team
     *
     * @param int $id Team ID to delete (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsIdDeleteAsync($id)
    {
        return $this->apiTeamsIdDeleteAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTeamsIdDeleteAsyncWithHttpInfo.
     *
     * Delete a team
     *
     * @param int $id Team ID to delete (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsIdDeleteAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->apiTeamsIdDeleteRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
                }
            );
    }

    /**
     * Create request for operation 'apiTeamsIdDelete'.
     *
     * @param int $id Team ID to delete (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiTeamsIdDeleteRequest($id)
    {
        // verify the required parameter 'id' is set
        if (null === $id || (\is_array($id) && 0 === \count($id))) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling apiTeamsIdDelete');
        }

        $resourcePath = '/api/teams/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if (null !== $id) {
            $resourcePath = str_replace(
                '{'.'id'.'}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (\count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = \is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name'     => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if (null !== $apiKey) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if (null !== $apiKey) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'DELETE',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTeamsIdGet.
     *
     * Returns one team
     *
     * @param string $id id (required)
     *
     * @throws \Fiteco\KimaiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Fiteco\KimaiClient\Model\TeamEntity
     */
    public function apiTeamsIdGet($id)
    {
        [$response] = $this->apiTeamsIdGetWithHttpInfo($id);

        return $response;
    }

    /**
     * Operation apiTeamsIdGetWithHttpInfo.
     *
     * Returns one team
     *
     * @param string $id (required)
     *
     * @throws \Fiteco\KimaiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Fiteco\KimaiClient\Model\TeamEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTeamsIdGetWithHttpInfo($id)
    {
        $request = $this->apiTeamsIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $request->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            switch ($statusCode) {
                case 200:
                    if ('\Fiteco\KimaiClient\Model\TeamEntity' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Fiteco\KimaiClient\Model\TeamEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Fiteco\KimaiClient\Model\TeamEntity';
            $responseBody = $response->getBody();
            if ('\SplFileObject' === $returnType) {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Fiteco\KimaiClient\Model\TeamEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation apiTeamsIdGetAsync.
     *
     * Returns one team
     *
     * @param string $id (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsIdGetAsync($id)
    {
        return $this->apiTeamsIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTeamsIdGetAsyncWithHttpInfo.
     *
     * Returns one team
     *
     * @param string $id (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\Fiteco\KimaiClient\Model\TeamEntity';
        $request = $this->apiTeamsIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ('\SplFileObject' === $returnType) {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
                }
            );
    }

    /**
     * Create request for operation 'apiTeamsIdGet'.
     *
     * @param string $id (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiTeamsIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if (null === $id || (\is_array($id) && 0 === \count($id))) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling apiTeamsIdGet');
        }

        $resourcePath = '/api/teams/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if (null !== $id) {
            $resourcePath = str_replace(
                '{'.'id'.'}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (\count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = \is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name'     => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if (null !== $apiKey) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if (null !== $apiKey) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTeamsIdMembersUserIdDelete.
     *
     * Removes a member from the team
     *
     * @param int $id     The team from which the member will be removed (required)
     * @param int $userId The team member to remove (User ID) (required)
     *
     * @throws \Fiteco\KimaiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Fiteco\KimaiClient\Model\TeamEntity
     */
    public function apiTeamsIdMembersUserIdDelete($id, $userId)
    {
        [$response] = $this->apiTeamsIdMembersUserIdDeleteWithHttpInfo($id, $userId);

        return $response;
    }

    /**
     * Operation apiTeamsIdMembersUserIdDeleteWithHttpInfo.
     *
     * Removes a member from the team
     *
     * @param int $id     The team from which the member will be removed (required)
     * @param int $userId The team member to remove (User ID) (required)
     *
     * @throws \Fiteco\KimaiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Fiteco\KimaiClient\Model\TeamEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTeamsIdMembersUserIdDeleteWithHttpInfo($id, $userId)
    {
        $request = $this->apiTeamsIdMembersUserIdDeleteRequest($id, $userId);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $request->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            switch ($statusCode) {
                case 200:
                    if ('\Fiteco\KimaiClient\Model\TeamEntity' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Fiteco\KimaiClient\Model\TeamEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Fiteco\KimaiClient\Model\TeamEntity';
            $responseBody = $response->getBody();
            if ('\SplFileObject' === $returnType) {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Fiteco\KimaiClient\Model\TeamEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation apiTeamsIdMembersUserIdDeleteAsync.
     *
     * Removes a member from the team
     *
     * @param int $id     The team from which the member will be removed (required)
     * @param int $userId The team member to remove (User ID) (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsIdMembersUserIdDeleteAsync($id, $userId)
    {
        return $this->apiTeamsIdMembersUserIdDeleteAsyncWithHttpInfo($id, $userId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTeamsIdMembersUserIdDeleteAsyncWithHttpInfo.
     *
     * Removes a member from the team
     *
     * @param int $id     The team from which the member will be removed (required)
     * @param int $userId The team member to remove (User ID) (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsIdMembersUserIdDeleteAsyncWithHttpInfo($id, $userId)
    {
        $returnType = '\Fiteco\KimaiClient\Model\TeamEntity';
        $request = $this->apiTeamsIdMembersUserIdDeleteRequest($id, $userId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ('\SplFileObject' === $returnType) {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
                }
            );
    }

    /**
     * Create request for operation 'apiTeamsIdMembersUserIdDelete'.
     *
     * @param int $id     The team from which the member will be removed (required)
     * @param int $userId The team member to remove (User ID) (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiTeamsIdMembersUserIdDeleteRequest($id, $userId)
    {
        // verify the required parameter 'id' is set
        if (null === $id || (\is_array($id) && 0 === \count($id))) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling apiTeamsIdMembersUserIdDelete');
        }
        // verify the required parameter 'userId' is set
        if (null === $userId || (\is_array($userId) && 0 === \count($userId))) {
            throw new \InvalidArgumentException('Missing the required parameter $userId when calling apiTeamsIdMembersUserIdDelete');
        }

        $resourcePath = '/api/teams/{id}/members/{userId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if (null !== $id) {
            $resourcePath = str_replace(
                '{'.'id'.'}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if (null !== $userId) {
            $resourcePath = str_replace(
                '{'.'userId'.'}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (\count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = \is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name'     => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if (null !== $apiKey) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if (null !== $apiKey) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'DELETE',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTeamsIdMembersUserIdPost.
     *
     * Add a new member to a team
     *
     * @param int $id     The team which will receive the new member (required)
     * @param int $userId The team member to add (User ID) (required)
     *
     * @throws \Fiteco\KimaiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Fiteco\KimaiClient\Model\TeamEntity
     */
    public function apiTeamsIdMembersUserIdPost($id, $userId)
    {
        [$response] = $this->apiTeamsIdMembersUserIdPostWithHttpInfo($id, $userId);

        return $response;
    }

    /**
     * Operation apiTeamsIdMembersUserIdPostWithHttpInfo.
     *
     * Add a new member to a team
     *
     * @param int $id     The team which will receive the new member (required)
     * @param int $userId The team member to add (User ID) (required)
     *
     * @throws \Fiteco\KimaiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Fiteco\KimaiClient\Model\TeamEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTeamsIdMembersUserIdPostWithHttpInfo($id, $userId)
    {
        $request = $this->apiTeamsIdMembersUserIdPostRequest($id, $userId);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $request->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            switch ($statusCode) {
                case 200:
                    if ('\Fiteco\KimaiClient\Model\TeamEntity' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Fiteco\KimaiClient\Model\TeamEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Fiteco\KimaiClient\Model\TeamEntity';
            $responseBody = $response->getBody();
            if ('\SplFileObject' === $returnType) {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Fiteco\KimaiClient\Model\TeamEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation apiTeamsIdMembersUserIdPostAsync.
     *
     * Add a new member to a team
     *
     * @param int $id     The team which will receive the new member (required)
     * @param int $userId The team member to add (User ID) (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsIdMembersUserIdPostAsync($id, $userId)
    {
        return $this->apiTeamsIdMembersUserIdPostAsyncWithHttpInfo($id, $userId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTeamsIdMembersUserIdPostAsyncWithHttpInfo.
     *
     * Add a new member to a team
     *
     * @param int $id     The team which will receive the new member (required)
     * @param int $userId The team member to add (User ID) (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsIdMembersUserIdPostAsyncWithHttpInfo($id, $userId)
    {
        $returnType = '\Fiteco\KimaiClient\Model\TeamEntity';
        $request = $this->apiTeamsIdMembersUserIdPostRequest($id, $userId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ('\SplFileObject' === $returnType) {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
                }
            );
    }

    /**
     * Create request for operation 'apiTeamsIdMembersUserIdPost'.
     *
     * @param int $id     The team which will receive the new member (required)
     * @param int $userId The team member to add (User ID) (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiTeamsIdMembersUserIdPostRequest($id, $userId)
    {
        // verify the required parameter 'id' is set
        if (null === $id || (\is_array($id) && 0 === \count($id))) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling apiTeamsIdMembersUserIdPost');
        }
        // verify the required parameter 'userId' is set
        if (null === $userId || (\is_array($userId) && 0 === \count($userId))) {
            throw new \InvalidArgumentException('Missing the required parameter $userId when calling apiTeamsIdMembersUserIdPost');
        }

        $resourcePath = '/api/teams/{id}/members/{userId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if (null !== $id) {
            $resourcePath = str_replace(
                '{'.'id'.'}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if (null !== $userId) {
            $resourcePath = str_replace(
                '{'.'userId'.'}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (\count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = \is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name'     => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if (null !== $apiKey) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if (null !== $apiKey) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTeamsIdPatch.
     *
     * Update an existing team
     *
     * @param int                                    $id   Team ID to update (required)
     * @param \Fiteco\KimaiClient\Model\TeamEditForm $body body (required)
     *
     * @throws \Fiteco\KimaiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Fiteco\KimaiClient\Model\TeamEntity
     */
    public function apiTeamsIdPatch($id, $body)
    {
        [$response] = $this->apiTeamsIdPatchWithHttpInfo($id, $body);

        return $response;
    }

    /**
     * Operation apiTeamsIdPatchWithHttpInfo.
     *
     * Update an existing team
     *
     * @param int                                    $id   Team ID to update (required)
     * @param \Fiteco\KimaiClient\Model\TeamEditForm $body (required)
     *
     * @throws \Fiteco\KimaiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Fiteco\KimaiClient\Model\TeamEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTeamsIdPatchWithHttpInfo($id, $body)
    {
        $request = $this->apiTeamsIdPatchRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $request->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            switch ($statusCode) {
                case 200:
                    if ('\Fiteco\KimaiClient\Model\TeamEntity' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Fiteco\KimaiClient\Model\TeamEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Fiteco\KimaiClient\Model\TeamEntity';
            $responseBody = $response->getBody();
            if ('\SplFileObject' === $returnType) {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Fiteco\KimaiClient\Model\TeamEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation apiTeamsIdPatchAsync.
     *
     * Update an existing team
     *
     * @param int                                    $id   Team ID to update (required)
     * @param \Fiteco\KimaiClient\Model\TeamEditForm $body (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsIdPatchAsync($id, $body)
    {
        return $this->apiTeamsIdPatchAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTeamsIdPatchAsyncWithHttpInfo.
     *
     * Update an existing team
     *
     * @param int                                    $id   Team ID to update (required)
     * @param \Fiteco\KimaiClient\Model\TeamEditForm $body (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsIdPatchAsyncWithHttpInfo($id, $body)
    {
        $returnType = '\Fiteco\KimaiClient\Model\TeamEntity';
        $request = $this->apiTeamsIdPatchRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ('\SplFileObject' === $returnType) {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
                }
            );
    }

    /**
     * Create request for operation 'apiTeamsIdPatch'.
     *
     * @param int                                    $id   Team ID to update (required)
     * @param \Fiteco\KimaiClient\Model\TeamEditForm $body (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiTeamsIdPatchRequest($id, $body)
    {
        // verify the required parameter 'id' is set
        if (null === $id || (\is_array($id) && 0 === \count($id))) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling apiTeamsIdPatch');
        }
        // verify the required parameter 'body' is set
        if (null === $body || (\is_array($body) && 0 === \count($body))) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling apiTeamsIdPatch');
        }

        $resourcePath = '/api/teams/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if (null !== $id) {
            $resourcePath = str_replace(
                '{'.'id'.'}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($body)) {
            if ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (\count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = \is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name'     => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if (null !== $apiKey) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if (null !== $apiKey) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'PATCH',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTeamsIdProjectsProjectIdDelete.
     *
     * Revokes access for a project from a team
     *
     * @param int $id        The team whose permission will be revoked (required)
     * @param int $projectId The project to remove (Project ID) (required)
     *
     * @throws \Fiteco\KimaiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Fiteco\KimaiClient\Model\TeamEntity
     */
    public function apiTeamsIdProjectsProjectIdDelete($id, $projectId)
    {
        [$response] = $this->apiTeamsIdProjectsProjectIdDeleteWithHttpInfo($id, $projectId);

        return $response;
    }

    /**
     * Operation apiTeamsIdProjectsProjectIdDeleteWithHttpInfo.
     *
     * Revokes access for a project from a team
     *
     * @param int $id        The team whose permission will be revoked (required)
     * @param int $projectId The project to remove (Project ID) (required)
     *
     * @throws \Fiteco\KimaiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Fiteco\KimaiClient\Model\TeamEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTeamsIdProjectsProjectIdDeleteWithHttpInfo($id, $projectId)
    {
        $request = $this->apiTeamsIdProjectsProjectIdDeleteRequest($id, $projectId);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $request->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            switch ($statusCode) {
                case 200:
                    if ('\Fiteco\KimaiClient\Model\TeamEntity' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Fiteco\KimaiClient\Model\TeamEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Fiteco\KimaiClient\Model\TeamEntity';
            $responseBody = $response->getBody();
            if ('\SplFileObject' === $returnType) {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Fiteco\KimaiClient\Model\TeamEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation apiTeamsIdProjectsProjectIdDeleteAsync.
     *
     * Revokes access for a project from a team
     *
     * @param int $id        The team whose permission will be revoked (required)
     * @param int $projectId The project to remove (Project ID) (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsIdProjectsProjectIdDeleteAsync($id, $projectId)
    {
        return $this->apiTeamsIdProjectsProjectIdDeleteAsyncWithHttpInfo($id, $projectId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTeamsIdProjectsProjectIdDeleteAsyncWithHttpInfo.
     *
     * Revokes access for a project from a team
     *
     * @param int $id        The team whose permission will be revoked (required)
     * @param int $projectId The project to remove (Project ID) (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsIdProjectsProjectIdDeleteAsyncWithHttpInfo($id, $projectId)
    {
        $returnType = '\Fiteco\KimaiClient\Model\TeamEntity';
        $request = $this->apiTeamsIdProjectsProjectIdDeleteRequest($id, $projectId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ('\SplFileObject' === $returnType) {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
                }
            );
    }

    /**
     * Create request for operation 'apiTeamsIdProjectsProjectIdDelete'.
     *
     * @param int $id        The team whose permission will be revoked (required)
     * @param int $projectId The project to remove (Project ID) (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiTeamsIdProjectsProjectIdDeleteRequest($id, $projectId)
    {
        // verify the required parameter 'id' is set
        if (null === $id || (\is_array($id) && 0 === \count($id))) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling apiTeamsIdProjectsProjectIdDelete');
        }
        // verify the required parameter 'projectId' is set
        if (null === $projectId || (\is_array($projectId) && 0 === \count($projectId))) {
            throw new \InvalidArgumentException('Missing the required parameter $projectId when calling apiTeamsIdProjectsProjectIdDelete');
        }

        $resourcePath = '/api/teams/{id}/projects/{projectId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if (null !== $id) {
            $resourcePath = str_replace(
                '{'.'id'.'}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if (null !== $projectId) {
            $resourcePath = str_replace(
                '{'.'projectId'.'}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (\count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = \is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name'     => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if (null !== $apiKey) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if (null !== $apiKey) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'DELETE',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTeamsIdProjectsProjectIdPost.
     *
     * Grant the team access to a project
     *
     * @param int $id        The team that is granted access (required)
     * @param int $projectId The project to grant acecess to (Project ID) (required)
     *
     * @throws \Fiteco\KimaiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Fiteco\KimaiClient\Model\TeamEntity
     */
    public function apiTeamsIdProjectsProjectIdPost($id, $projectId)
    {
        [$response] = $this->apiTeamsIdProjectsProjectIdPostWithHttpInfo($id, $projectId);

        return $response;
    }

    /**
     * Operation apiTeamsIdProjectsProjectIdPostWithHttpInfo.
     *
     * Grant the team access to a project
     *
     * @param int $id        The team that is granted access (required)
     * @param int $projectId The project to grant acecess to (Project ID) (required)
     *
     * @throws \Fiteco\KimaiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Fiteco\KimaiClient\Model\TeamEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTeamsIdProjectsProjectIdPostWithHttpInfo($id, $projectId)
    {
        $request = $this->apiTeamsIdProjectsProjectIdPostRequest($id, $projectId);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $request->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            switch ($statusCode) {
                case 200:
                    if ('\Fiteco\KimaiClient\Model\TeamEntity' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Fiteco\KimaiClient\Model\TeamEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Fiteco\KimaiClient\Model\TeamEntity';
            $responseBody = $response->getBody();
            if ('\SplFileObject' === $returnType) {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Fiteco\KimaiClient\Model\TeamEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation apiTeamsIdProjectsProjectIdPostAsync.
     *
     * Grant the team access to a project
     *
     * @param int $id        The team that is granted access (required)
     * @param int $projectId The project to grant acecess to (Project ID) (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsIdProjectsProjectIdPostAsync($id, $projectId)
    {
        return $this->apiTeamsIdProjectsProjectIdPostAsyncWithHttpInfo($id, $projectId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTeamsIdProjectsProjectIdPostAsyncWithHttpInfo.
     *
     * Grant the team access to a project
     *
     * @param int $id        The team that is granted access (required)
     * @param int $projectId The project to grant acecess to (Project ID) (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsIdProjectsProjectIdPostAsyncWithHttpInfo($id, $projectId)
    {
        $returnType = '\Fiteco\KimaiClient\Model\TeamEntity';
        $request = $this->apiTeamsIdProjectsProjectIdPostRequest($id, $projectId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ('\SplFileObject' === $returnType) {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
                }
            );
    }

    /**
     * Create request for operation 'apiTeamsIdProjectsProjectIdPost'.
     *
     * @param int $id        The team that is granted access (required)
     * @param int $projectId The project to grant acecess to (Project ID) (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiTeamsIdProjectsProjectIdPostRequest($id, $projectId)
    {
        // verify the required parameter 'id' is set
        if (null === $id || (\is_array($id) && 0 === \count($id))) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling apiTeamsIdProjectsProjectIdPost');
        }
        // verify the required parameter 'projectId' is set
        if (null === $projectId || (\is_array($projectId) && 0 === \count($projectId))) {
            throw new \InvalidArgumentException('Missing the required parameter $projectId when calling apiTeamsIdProjectsProjectIdPost');
        }

        $resourcePath = '/api/teams/{id}/projects/{projectId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if (null !== $id) {
            $resourcePath = str_replace(
                '{'.'id'.'}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if (null !== $projectId) {
            $resourcePath = str_replace(
                '{'.'projectId'.'}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (\count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = \is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name'     => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if (null !== $apiKey) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if (null !== $apiKey) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiTeamsPost.
     *
     * Creates a new team
     *
     * @param \Fiteco\KimaiClient\Model\TeamEditForm $body body (required)
     *
     * @throws \Fiteco\KimaiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Fiteco\KimaiClient\Model\TeamEntity
     */
    public function apiTeamsPost($body)
    {
        [$response] = $this->apiTeamsPostWithHttpInfo($body);

        return $response;
    }

    /**
     * Operation apiTeamsPostWithHttpInfo.
     *
     * Creates a new team
     *
     * @param \Fiteco\KimaiClient\Model\TeamEditForm $body (required)
     *
     * @throws \Fiteco\KimaiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Fiteco\KimaiClient\Model\TeamEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiTeamsPostWithHttpInfo($body)
    {
        $request = $this->apiTeamsPostRequest($body);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $request->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            switch ($statusCode) {
                case 200:
                    if ('\Fiteco\KimaiClient\Model\TeamEntity' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Fiteco\KimaiClient\Model\TeamEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\Fiteco\KimaiClient\Model\TeamEntity';
            $responseBody = $response->getBody();
            if ('\SplFileObject' === $returnType) {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Fiteco\KimaiClient\Model\TeamEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation apiTeamsPostAsync.
     *
     * Creates a new team
     *
     * @param \Fiteco\KimaiClient\Model\TeamEditForm $body (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsPostAsync($body)
    {
        return $this->apiTeamsPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiTeamsPostAsyncWithHttpInfo.
     *
     * Creates a new team
     *
     * @param \Fiteco\KimaiClient\Model\TeamEditForm $body (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiTeamsPostAsyncWithHttpInfo($body)
    {
        $returnType = '\Fiteco\KimaiClient\Model\TeamEntity';
        $request = $this->apiTeamsPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ('\SplFileObject' === $returnType) {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
                }
            );
    }

    /**
     * Create request for operation 'apiTeamsPost'.
     *
     * @param \Fiteco\KimaiClient\Model\TeamEditForm $body (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiTeamsPostRequest($body)
    {
        // verify the required parameter 'body' is set
        if (null === $body || (\is_array($body) && 0 === \count($body))) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling apiTeamsPost');
        }

        $resourcePath = '/api/teams';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($body)) {
            if ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (\count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = \is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name'     => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if (null !== $apiKey) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-USER');
        if (null !== $apiKey) {
            $headers['X-AUTH-USER'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option.
     *
     * @throws \RuntimeException on file opening failure
     *
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: '.$this->config->getDebugFile());
            }
        }

        return $options;
    }
}
